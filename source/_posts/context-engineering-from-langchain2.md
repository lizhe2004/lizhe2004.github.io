---
title: "上下文工程"的兴起（翻译自langchain博客）
toc: true
date: 2025-07-07
tags: [Context Engineering,大模型,Agent,智能体]
categories: [人工智能]
description: langchain 关于Context Engineering的理解和介绍，主要包括上下文工程的定义、构成要素以及技术策略
banner: https://cdn.jsdmirror.com/gh/lizhe2004/pic-repo@master//imgs/20250707154223.png
cover: https://cdn.jsdmirror.com/gh/lizhe2004/pic-repo@master//imgs/20250707154223.png
author: 李大侠
breadcrumb: true
leftbar:
  - recent
  - related
  - tagcloud
rightbar:
  - toc
---
原文 链接：https://blog.langchain.com/the-rise-of-context-engineering/

# "上下文工程"的兴起
 
 
上下文工程是指构建动态系统，以正确的格式提供正确的信息和工具，使LLM能够合理完成任务。

大多数情况下，当代理表现不可靠时，根本原因是未向模型传达适当的上下文、指令和工具。

LLM应用正在从单一提示演变为更复杂、动态的代理系统。因此，上下文工程正在成为AI工程师可以开发的最重要技能。

## 什么是上下文工程？
上下文工程是指构建动态系统，以正确的格式提供正确的信息和工具，使LLM能够合理完成任务。

这是我喜欢的一个定义，它建立在Tobi Lutke、Ankur Goyal和Walden Yan最近的观点之上。让我们分解一下。

### 上下文工程是一个系统
复杂的代理可能从许多来源获取上下文。上下文可以来自应用程序的开发人员、用户、先前的交互、工具调用或其他外部数据。将这些全部整合在一起需要一个复杂的系统。

### 这个系统是动态的
许多这些上下文片段可以动态地出现。因此，构建最终提示的逻辑也需要是动态的。它不仅仅是一个静态提示。

### 你需要正确的信息
代理系统表现不佳的一个常见原因是它们没有正确的上下文。LLM不能读心术——你需要给它们正确的信息。垃圾进，垃圾出。

### 你需要正确的工具
LLM并不总是能够仅基于输入解决问题。在这些情况下，如果你想授权LLM这样做，你需要确保它有正确的工具。这些可以是查找更多信息、采取行动或介于两者之间的任何工具。给LLM正确的工具与给它正确的信息同样重要。

### 格式很重要
就像与人类交流一样，你如何与LLM交流也很重要。一个简短但描述性的错误信息比一个大的JSON块更有用。这也适用于工具。工具的输入参数在确保LLM可以使用它们时非常重要。

### 它能合理完成任务吗？
这是一个很好的问题，可以帮助你思考上下文工程。它强调LLM不是读心术者——你需要为它们创造成功条件。它还有助于区分故障模式。是因为你没有给它正确的信息或工具而失败，还是它拥有所有正确的信息但搞砸了？这些故障模式有非常不同的修复方法。

## 为什么上下文工程很重要
当代理系统出错时，很大程度上是因为LLM出错了。从第一性原理思考，LLM出错有两个原因：

底层模型出错了，它不够好
底层模型没有传递适当的上下文来产生好的输出
更多时候（尤其是随着模型变得更好），模型错误更多是由第二个原因引起的。传递给模型的上下文可能因为几个原因而不好：

缺少模型做出正确决策所需的上下文。模型不是读心术者。如果你不给它们正确的上下文，它们就不会知道它的存在。
上下文格式不好。就像人类一样，沟通很重要！你如何格式化数据传递给模型绝对会影响它的响应方式。
## 上下文工程与提示工程有何不同？
为什么从"提示"转向"上下文"？早期，开发人员专注于巧妙地措辞提示以获得更好的答案。但随着应用程序变得越来越复杂，很明显，为AI提供完整和结构化的上下文比任何神奇的措辞都重要得多。

我还认为提示工程是上下文工程的一个子集。即使你拥有所有上下文，你如何在提示中组装它仍然非常重要。不同之处在于，你不是为了与一组输入数据良好配合而设计提示，而是为了获取一组动态数据并正确格式化它。

我还要强调，上下文的一个关键部分通常是关于LLM应该如何行为的核心指令。这通常是提示工程的一个关键部分。你会说提供关于代理应该如何行为的清晰详细指令是上下文工程还是提示工程？我认为两者兼而有之。

## 上下文工程的例子
一些好的上下文工程的基本例子包括：

工具使用：确保如果代理需要访问外部信息，它有可以访问的工具。当工具返回信息时，它们以LLM最容易消化的方式格式化。
短期记忆：如果对话持续一段时间，创建对话摘要并在将来使用它。
长期记忆：如果用户在之前的对话中表达了偏好，能够获取该信息。
提示工程：关于代理应该如何行为的指令在提示中明确列举。
检索：动态获取信息并在调用LLM之前将其插入提示中。
### LangGraph如何实现上下文工程
当我们构建LangGraph时，我们的目标是使其成为最具可控性的代理框架。这也使它能够完美地实现上下文工程。

使用LangGraph，你可以控制一切。你决定运行哪些步骤。你决定什么进入你的LLM。你决定在哪里存储输出。你控制一切。

这允许你做所有你想要的上下文工程。代理抽象（大多数其他代理框架强调）的一个缺点是它们限制了上下文工程。可能有些地方你不能改变进入LLM的确切内容，或者之前运行的确切步骤。

旁注：Dex Horthy的"12 Factor Agents"是一篇非常好的读物。那里的许多观点都与上下文工程有关（"拥有你的提示"，"拥有你的上下文构建"等）。这篇博客的头图也来自Dex。我们非常喜欢他关于这个领域重要性的沟通方式。

### LangSmith如何帮助上下文工程
LangSmith是我们的LLM应用可观察性和评估解决方案。LangSmith的一个关键功能是能够跟踪你的代理调用。尽管我们在构建LangSmith时"上下文工程"这个术语还不存在，但它恰当地描述了这种跟踪帮助的内容。

LangSmith让你看到代理中发生的所有步骤。这让你看到运行了哪些步骤来收集发送到LLM的数据。

LangSmith让你看到LLM的确切输入和输出。这让你看到进入LLM的确切内容——它拥有的数据以及如何格式化。然后你可以调试是否包含完成任务所需的所有相关信息。这包括LLM可以访问的工具——所以你可以调试是否给了它适当的工具来帮助完成任务。

### 沟通就是一切
几个月前，我写了一篇名为"沟通就是一切"的博客。主要观点是与LLM沟通很难，而且不够重视，通常是许多代理错误的根本原因。许多这些观点都与上下文工程有关！

上下文工程并不是一个新想法——代理构建者已经做了过去一两年。这是一个新术语，恰当地描述了一项日益重要的技能。我们将在这个主题上写更多并分享更多。我们认为我们构建的许多工具（LangGraph、LangSmith）都是完美构建来实现上下文工程的，所以我们很高兴看到对这方面的重视。